# Dashboard Improvement Plan

**Stack:** Next.js 16.1.6 · React 19 · Tailwind CSS v4 · TypeScript
**Author:** Generated by Claude Sonnet 4.6 for Claude Opus to execute

---

## Overview

Three phases of work, in priority order:

1. **Contrast & Polish** — Fix specific WCAG failures and rough visual edges
2. **Responsive Design** — Mobile-first layout, collapsible sidebar, responsive grids
3. **Functional Kanban** — Real drag-and-drop in Pipeline with Airtable write-back

Future work (noted here, not in scope for this session): n8n integration (pause/resume executions panel).

---

## Phase 1 — Contrast & Visual Polish

### 1.1 Specific Contrast Failures

These are concrete WCAG AA failures (< 4.5:1 for normal text, < 3:1 for large text).
Fix each one by upgrading the text color to the next Tailwind step up.

| File | Line | Current class | Problem | Fix |
|------|------|--------------|---------|-----|
| `src/components/layout/Sidebar.tsx` | 84 | `text-gray-600` | "Mock Data Active" on `bg-gray-900` (~2.7:1) | `text-gray-400` |
| `src/components/pages/PipelineClient.tsx` | 67 | `text-gray-600` | "Keine Einträge" empty state on `bg-gray-900` (~2.7:1) | `text-gray-400` |
| `src/components/pages/PipelineClient.tsx` | 92 | `text-gray-500` | Notes italic text on `bg-gray-800/50` (~3.1:1, borderline) | `text-gray-400` |
| `src/components/ui/ListingTable.tsx` | 199 | `text-gray-600` | Count footer "X von Y Einträgen" on `bg-gray-950` (~2.0:1) | `text-gray-400` |
| `src/components/ui/ListingCard.tsx` | 59 | `text-gray-600` | Source label ("ImmoScout24") on `bg-gray-900` (~2.7:1) | `text-gray-400` |
| `src/components/ui/ListingTable.tsx` | 94 | `placeholder:text-gray-600` | Search input placeholder | `placeholder:text-gray-500` |
| `src/components/ui/DetailDrawer.tsx` | 93, 110, 125, 145, 157, 169, 184 | `text-gray-500` | Section headings on `bg-gray-900` | `text-gray-400` |

### 1.2 globals.css Variable Mismatch

`src/app/globals.css` defines `--color-background: #030712` but `body` uses `var(--background)` (Tailwind default), not `var(--color-background)`. This is a Tailwind v4 theme variable — the correct Tailwind v4 CSS variable name for `--color-background` is `--color-background`, which is consumed as `bg-background`. However, the layout uses `bg-gray-950` directly on `<body>`, so the theme variable is effectively unused. Clean this up: either remove the dead `--color-background` declaration, or align the body class to use `bg-background`.
**Recommendation:** Remove the `@theme inline` block entirely from `globals.css` since the colors are set directly in component classes. This avoids confusion.

### 1.3 Visual Polish

These don't affect accessibility but improve the overall quality:

**Sidebar (`src/components/layout/Sidebar.tsx`):**
- The "RE Screener" title uses `text-sm` — bump to `text-base` for better visual weight
- Active nav item background is `bg-gray-800` — add a subtle left-border accent: `border-l-2 border-blue-500 pl-[10px]` (adjust padding to compensate) for a modern active indicator
- The logo area has a blue rounded square icon. Looks fine. Keep it.

**StatsCard (`src/components/ui/StatsCard.tsx`):**
- Currently plain card with no icon. For polish, add a colored icon or accent dot per color variant. The card label uses `uppercase tracking-wider` which is good. Add a colored left-border or subtle gradient top-border per color to visually differentiate the cards (matching the pipeline column style: `border-t-2 border-t-emerald-500`, etc.)

**ListingCard (`src/components/ui/ListingCard.tsx`):**
- The footer divider `border-gray-800` on `bg-gray-900` is nearly invisible. Use `border-gray-700` instead.
- Add `group` to the button and `group-hover:text-blue-300` to the "Details →" link for a hover micro-interaction.

**DetailDrawer (`src/components/ui/DetailDrawer.tsx`):**
- The Key Metrics cards use `bg-gray-800/50` — these are hard to distinguish from the drawer background. Use `bg-gray-800` (without opacity) for solid contrast.
- The close button `text-gray-500 hover:text-gray-300` — make the hover target larger: add `rounded-lg p-2` (remove the current `p-1`).

**PipelineClient (`src/components/pages/PipelineClient.tsx`):**
- Pipeline cards use `bg-gray-800/50 border border-gray-800` — the border is nearly invisible against the semi-transparent background. Use `bg-gray-800 border border-gray-700` for a crisper card edge.

---

## Phase 2 — Responsive Design

### 2.1 Mobile Sidebar (Collapsible)

**Problem:** `Sidebar.tsx` renders as `w-64 shrink-0`, always visible. On screens < 768px this takes up ~256px of a 375px screen, leaving ~119px for content — unusable.

**Solution:** Convert to a slide-in drawer on mobile with a hamburger toggle.

**Changes required:**

1. **`src/components/layout/Sidebar.tsx`** — Convert to a client component (`'use client'`). Accept an `isOpen` prop or manage state internally with a toggle. On mobile (`lg:hidden` / `lg:flex`):
   - Default: hidden, slides in from left over content with backdrop
   - `w-64 fixed inset-y-0 left-0 z-50 transform transition-transform`
   - When closed: `-translate-x-full`
   - When open: `translate-x-0`
   - On desktop (`lg:`): always visible, static positioning (current behavior)

2. **`src/app/layout.tsx`** — Add a `<MobileHeader>` component (new file `src/components/layout/MobileHeader.tsx`) that renders on mobile only (`lg:hidden`). It shows:
   - Hamburger button (left)
   - "RE Screener" title (center)
   - Nothing or a placeholder (right) for balance
   This header manages sidebar open/close state via a shared context or by lifting state into the layout.

3. **State management:** Use a `SidebarProvider` context (`src/components/layout/SidebarContext.tsx`) with `isOpen`/`setIsOpen`, so both `MobileHeader` and `Sidebar` can access it without prop drilling through the layout.

4. **Backdrop:** When sidebar is open on mobile, render a `div.fixed.inset-0.bg-black/50.z-40` that closes the sidebar on click.

**Layout structure after change:**
```
<body class="flex h-screen overflow-hidden bg-gray-950">
  <SidebarProvider>
    <Sidebar />                    {/* fixed on mobile, static on desktop */}
    <div class="flex-1 flex flex-col min-w-0">
      <MobileHeader />             {/* lg:hidden */}
      <main class="flex-1 overflow-y-auto">
        <div class="p-4 sm:p-6 max-w-[1600px] mx-auto">
          {children}
        </div>
      </main>
    </div>
  </SidebarProvider>
</body>
```

### 2.2 Responsive Grids

**`src/components/pages/DashboardClient.tsx` line 45:**
```tsx
// Current (breaks on mobile — 4 narrow columns)
className="grid grid-cols-4 gap-4 mb-8"

// Fix
className="grid grid-cols-2 sm:grid-cols-4 gap-4 mb-8"
```

**`src/components/pages/HistoryClient.tsx` line 66:**
```tsx
// Current
className="grid grid-cols-4 gap-4 mb-8"

// Fix
className="grid grid-cols-2 sm:grid-cols-4 gap-4 mb-8"
```

**`src/app/layout.tsx` line 20:**
```tsx
// Current
className="p-6 max-w-[1600px] mx-auto"

// Fix
className="p-4 sm:p-6 max-w-[1600px] mx-auto"
```

### 2.3 Responsive Table

The `ListingTable` is a full `<table>` — on mobile screens it requires horizontal scroll, which is functional but not ideal.

**Two options:**
- **Option A (simpler):** Keep the table but ensure `overflow-x-auto` is on the wrapper (already present at line 102) and reduce font sizes slightly on mobile. Make some columns conditionally hidden on small screens: hide `Energie` and `Analysiert` columns on `< md`.
- **Option B (better UX):** On mobile, swap the table for a stacked card list using CSS (`hidden md:table` on the table, `md:hidden` on a card list). This is more work but looks significantly better.

**Recommendation for Opus:** Implement Option A first (quick win), note Option B as a follow-up.

For Option A, add responsive column visibility:
```tsx
// In <th> for Energie and Analysiert
className="px-4 py-3 font-medium hidden md:table-cell"

// In <td> for those columns
className="px-4 py-3 hidden md:table-cell"
```

Also: the filter bar (`flex items-center justify-between flex-wrap`) on mobile will stack the status filters and search input. Add `w-full sm:w-64` to the search input so it fills width on mobile.

### 2.4 DetailDrawer on Mobile

The drawer is `w-[520px] max-w-[90vw]` — the `max-w-[90vw]` handles mobile width correctly. But on very small screens (320px), `90vw = 288px` which is tight. Consider `max-w-full sm:max-w-[520px]` with full-width on mobile for better readability, sliding up from the bottom (sheet pattern) instead of from the right.

**Recommendation:** On mobile (`< sm`), switch to a bottom sheet:
- `fixed bottom-0 left-0 right-0 h-[85vh] rounded-t-2xl`
- Translate: `translate-y-full` → `translate-y-0`
- On desktop: keep current right-side drawer

Use a `useMediaQuery('(min-width: 640px)')` hook or a CSS-only approach with Tailwind variants.

### 2.5 Pipeline Kanban on Mobile

The kanban uses `flex gap-4 overflow-x-auto pb-4` with `min-w-[280px] flex-1`. This already handles mobile with horizontal scroll — this is the right pattern for kanban on mobile. No major changes needed here, but:
- Add `-mx-4 px-4` to the container (or `px-4` on columns) so cards extend to screen edges on mobile
- Add scroll snap: `scroll-snap-type: x mandatory` on the container, `scroll-snap-align: start` on columns

---

## Phase 3 — Functional Kanban with Drag & Drop

### 3.1 Library Choice

Use **`@dnd-kit/core`** + **`@dnd-kit/sortable`** (not `react-beautiful-dnd` which has React 18+ issues, and not `@hello-pangea/dnd` which is heavier).

```bash
npm install @dnd-kit/core @dnd-kit/sortable @dnd-kit/utilities
```

These packages are compatible with React 19 and Next.js App Router (client components).

### 3.2 Architecture

Convert `PipelineClient.tsx` to manage local state for listings (optimistic updates):

```
PipelineClient (manages: listings state, active drag item)
├── DndContext (onDragStart, onDragEnd)
│   ├── KanbanColumn (per stage) — receives items, SortableContext
│   │   └── KanbanCard (each listing) — useSortable
│   └── DragOverlay (floating preview of dragged card)
```

**State flow for a drag:**
1. `onDragStart`: record the `active` item id
2. `onDragEnd`: receive `{ active, over }` — `over` is either another card (for ordering within column) or a column droppable
3. Optimistic update: move listing to new `Pipeline Stage` in local state immediately
4. API call: `PATCH /api/listings/[id]` with `{ 'Pipeline Stage': newStage }`
5. On error: revert local state, show a toast/error indicator

### 3.3 Droppable Columns

Each column needs to be both a SortableContext (for reordering within column) and a Droppable (to accept cards from other columns). Use `useDroppable` from `@dnd-kit/core` on each column container.

```tsx
// KanbanColumn.tsx (new component)
import { useDroppable } from '@dnd-kit/core';
import { SortableContext, verticalListSortingStrategy } from '@dnd-kit/sortable';

function KanbanColumn({ stage, label, color, items }) {
  const { setNodeRef, isOver } = useDroppable({ id: stage });

  return (
    <div ref={setNodeRef} className={cn(
      'min-w-[280px] flex-1 bg-gray-900 rounded-xl border border-gray-800 border-t-2 transition-colors',
      col.color,
      isOver && 'ring-2 ring-blue-500/50'  // visual feedback when dragging over
    )}>
      {/* column header */}
      <SortableContext items={items.map(i => i.id)} strategy={verticalListSortingStrategy}>
        {items.map(item => <KanbanCard key={item.id} listing={item} />)}
      </SortableContext>
    </div>
  );
}
```

### 3.4 Sortable Cards

```tsx
// KanbanCard.tsx (new component, extracted from PipelineClient)
import { useSortable } from '@dnd-kit/sortable';
import { CSS } from '@dnd-kit/utilities';

function KanbanCard({ listing, onClick }) {
  const {
    attributes, listeners, setNodeRef,
    transform, transition, isDragging
  } = useSortable({ id: listing.id });

  const style = {
    transform: CSS.Transform.toString(transform),
    transition,
    opacity: isDragging ? 0.4 : 1,
  };

  return (
    <div ref={setNodeRef} style={style} {...attributes}>
      {/* drag handle — separate from click area */}
      <div {...listeners} className="cursor-grab active:cursor-grabbing p-1">
        <GripVerticalIcon className="w-4 h-4 text-gray-600" />
      </div>
      {/* card content — clickable for drawer */}
      <button onClick={onClick}>...</button>
    </div>
  );
}
```

Note: Separate the drag handle (`listeners`) from the card click target (`onClick`) to avoid conflicts.

### 3.5 Airtable Write-Back

**New API route:** `src/app/api/listings/[id]/route.ts` — add a `PATCH` handler (the GET already exists):

```ts
export async function PATCH(
  request: NextRequest,
  { params }: { params: Promise<{ id: string }> }
) {
  const { id } = await params;
  const body = await request.json();

  // Only allow updating specific safe fields
  const allowedFields = ['Pipeline Stage', 'Notes', 'next_action_date'];
  const fields: Record<string, unknown> = {};
  for (const key of allowedFields) {
    if (key in body) fields[key] = body[key];
  }

  if (Object.keys(fields).length === 0) {
    return NextResponse.json({ error: 'No valid fields to update' }, { status: 400 });
  }

  // Mock mode: just return success
  if (USE_MOCK) {
    return NextResponse.json({ success: true });
  }

  const res = await fetch(`${AIRTABLE_URL}/${id}`, {
    method: 'PATCH',
    headers: {
      Authorization: `Bearer ${AIRTABLE_API_KEY}`,
      'Content-Type': 'application/json',
    },
    body: JSON.stringify({ fields }),
  });

  if (!res.ok) {
    return NextResponse.json({ error: 'Airtable update failed' }, { status: 500 });
  }

  return NextResponse.json({ success: true });
}
```

**Export `USE_MOCK` and `AIRTABLE_URL` from `airtable.ts`** so the route handler can import them, or duplicate the env var reads in the route (simpler).

### 3.6 Optimistic Update Pattern in PipelineClient

```tsx
export function PipelineClient({ listings: initialListings }) {
  const [listings, setListings] = useState(initialListings);

  async function handleDragEnd({ active, over }) {
    if (!over || active.id === over.id) return;

    // Determine target stage (over could be a column id or a card id)
    const targetStage = resolveTargetStage(over.id, listings);
    if (!targetStage) return;

    const listing = listings.find(l => l.id === active.id);
    if (!listing || listing['Pipeline Stage'] === targetStage) return;

    // Optimistic update
    const previous = listings;
    setListings(prev => prev.map(l =>
      l.id === active.id ? { ...l, 'Pipeline Stage': targetStage } : l
    ));

    // Persist
    try {
      await fetch(`/api/listings/${active.id}`, {
        method: 'PATCH',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ 'Pipeline Stage': targetStage }),
      });
    } catch {
      setListings(previous); // revert on error
    }
  }
}
```

---

## Implementation Order for Opus

Work through phases in this order. Each phase is independently shippable:

### Phase 1 (start here — ~45 min)
1. Fix all contrast issues in the table above (mechanical find-replace)
2. Clean up `globals.css` variable mismatch
3. Apply polish improvements (card borders, hover states, section heading colors)
4. Verify: all gray-600 usages on dark backgrounds are gone

### Phase 2 (~90 min)
1. Create `src/components/layout/SidebarContext.tsx`
2. Refactor `Sidebar.tsx` to use context + mobile slide-in behavior
3. Create `src/components/layout/MobileHeader.tsx`
4. Update `layout.tsx` to wrap in SidebarProvider and include MobileHeader
5. Fix responsive grids in DashboardClient and HistoryClient
6. Fix responsive table column visibility in ListingTable
7. Make DetailDrawer a bottom-sheet on mobile
8. Test at 375px, 768px, 1280px widths

### Phase 3 (~90 min)
1. `npm install @dnd-kit/core @dnd-kit/sortable @dnd-kit/utilities`
2. Extract `KanbanCard.tsx` from PipelineClient (new component)
3. Extract `KanbanColumn.tsx` from PipelineClient (new component)
4. Add `PATCH` handler to `src/app/api/listings/[id]/route.ts`
5. Rewrite `PipelineClient.tsx` with DndContext, optimistic updates, API call
6. Test drag between columns, revert on error, drag overlay visual

---

## Files to Create (net new)
- `src/components/layout/SidebarContext.tsx`
- `src/components/layout/MobileHeader.tsx`
- `src/components/ui/KanbanCard.tsx`
- `src/components/ui/KanbanColumn.tsx`

## Files to Modify
- `src/app/globals.css` — remove dead theme variables
- `src/app/layout.tsx` — SidebarProvider, MobileHeader, responsive padding
- `src/components/layout/Sidebar.tsx` — mobile behavior
- `src/components/pages/DashboardClient.tsx` — responsive grid
- `src/components/pages/HistoryClient.tsx` — responsive grid
- `src/components/pages/PipelineClient.tsx` — full rewrite for dnd-kit
- `src/components/ui/DetailDrawer.tsx` — contrast fixes, bottom-sheet mobile
- `src/components/ui/ListingCard.tsx` — contrast fix, hover polish
- `src/components/ui/ListingTable.tsx` — contrast fix, responsive columns
- `src/components/ui/StatsCard.tsx` — colored border accents
- `src/app/api/listings/[id]/route.ts` — add PATCH handler

## Files NOT to touch
- `src/lib/types.ts` — types are correct
- `src/lib/mock-data.ts` — data is fine
- `src/lib/utils.ts` — utilities are fine
- `src/lib/airtable.ts` — may need minor export additions only
- All page-level files (`page.tsx`) — data fetching logic is correct

---

## Notes for Opus

- **Tailwind v4** is in use. The `@apply` directive works but prefer inline class strings. Use `cn()` from `@/lib/utils` for conditional classes (it's already a `clsx`/`tailwind-merge` wrapper).
- **React 19 + Next.js App Router**: PipelineClient is already `'use client'`. New components with hooks/interactivity need `'use client'` at the top.
- **dnd-kit** requires the `DndContext` and `SortableContext` to be client components. Do not place them in Server Components.
- **No SSR for dnd-kit**: If you see hydration errors with drag-and-drop, wrap the DndContext in a `dynamic(..., { ssr: false })` import.
- **Mock data mode**: `USE_MOCK_DATA=true` is likely set in `.env.local`. The PATCH endpoint should gracefully handle mock mode (just return success without calling Airtable).
- **Do not install** `react-beautiful-dnd` or `@hello-pangea/dnd` — they have known issues with React 19.
- **Run `npm run build`** after each phase to catch TypeScript errors before moving on.
